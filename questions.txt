Part 3:
	
















/*
   // This transforms the vertex into world coordinates
   // gl_ModelViewMatrix is whatever matrix that's on top of the GL_MODELVIEW stack
   position = gl_ModelViewMatrix * gl_Vertex;
	*/


backups:

/*
	printf("%s", "A string"); 
   vec2 st = gl_TexCoord[0].st;
   vec4 textureColor = texture2D(textureSampler, st); 
   if (textureColor[0] == 0.0) 
	 gl_FragColor = textureColor;
   else
     gl_FragColor = vec4(vec3(0.9, 0.9, 0.0), 1.0);
   */



/*
   // Variables used for calculations declared here
   vec3 lightDirection;
   vec3 finalColor = vec3(0.0, 0.0, 0.9);

   // Loop through the 8 lights supported by OpenGL.
   // Now you know what the light IDs are used for!
   for (int i = 0; i < 8; i++){
      // Calculate the light direction
      lightDirection = gl_LightSource[i].position.xyz - position.xyz;

      // Determine if the light is in front of the surface.
      // If it is, I want to highlight it yellow
      if(dot(normal, lightDirection) >= 0.0)
         finalColor = vec3(0.9, 0.9, 0.0);
   }

   // Return the color for this fragment. It will be blue if no light
   // shines on it, and yellow if it receives light. GO TRITONS!
   gl_FragColor = vec4(finalColor, 1.0);

   if (gl_FragColor[0] == 0.0)
		std::cout << "black" << std::endl;
	if (gl_FragColor[0] == 1.0)
		std::cout << "white" << std::endl;
   */